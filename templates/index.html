<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise AI Assistant - OpenRouter</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js" defer></script>

    <style>
        :root {
            --primary-bg: #f4f8fa;
            --container-bg: #ffffff;
            --header-bg: #005A9C;
            --sidebar-bg: #f8f9fa;
            --text-primary: #212529;
            --text-secondary: #495057;
            --text-light: #ffffff;
            --border-color: #dee2e6;
            --accent-color: #007bff;
            --accent-hover: #0056b3;
            --error-color: #dc3545;
            --success-color: #28a745;
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius: 8px;
            --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            --tab-active-bg: var(--accent-color);
            --tab-inactive-bg: #e9ecef;
            --tab-active-text: var(--text-light);
            --tab-inactive-text: var(--text-secondary);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: var(--font-family);
            background-color: var(--primary-bg);
            color: var(--text-primary);
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
        }
        .app-container {
            width: 100%;
            max-width: 1400px;
            background: var(--container-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 40px);
        }
        .app-header {
            background-color: var(--header-bg);
            padding: 15px 25px;
            color: var(--text-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .app-header-title h1 { font-size: 1.6em; margin: 0; font-weight: 600; }
        .app-header-info { text-align: right; font-size: 0.85em; }
        .app-header-info div { margin-bottom: 3px; opacity: 0.9; }
        #tehran-time-display { font-weight: 500; }
        #api-status-text { font-weight: 500; }

        .app-main-layout { display: flex; flex-grow: 1; overflow: hidden; }
        .main-content-area { /* Replaces chat-area */
            flex: 3;
            display: flex;
            flex-direction: column;
            padding: 0px 20px 20px 20px; /* No top padding here, tabs will have it */
            border-right: 1px solid var(--border-color);
            overflow: hidden;
        }
        .tabs-nav {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px; /* Space between tabs and content */
            flex-shrink: 0;
        }
        .tab-button {
            padding: 12px 20px;
            cursor: pointer;
            border: none;
            background-color: var(--tab-inactive-bg);
            color: var(--tab-inactive-text);
            font-size: 1em;
            font-weight: 500;
            transition: background-color 0.3s, color 0.3s;
            border-top-left-radius: var(--border-radius);
            border-top-right-radius: var(--border-radius);
            margin-right: 2px;
        }
        .tab-button.active {
            background-color: var(--tab-active-bg);
            color: var(--tab-active-text);
            border-bottom: 2px solid var(--accent-color); /* Highlight active tab */
        }
        .tab-button:hover:not(.active) { background-color: #d8dcdf; }

        .tab-content {
            display: none; /* Hidden by default */
            flex-grow: 1;
            overflow: hidden; /* Important for internal elements to scroll */
            flex-direction: column; /* Make tab content a flex container */
        }
        .tab-content.active { display: flex; /* Show active tab */ }

        /* Chat Area specific styles */
        .chat-interaction-wrapper { /* New wrapper for chat history + input */
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden; /* This allows chat-history-container to scroll */
        }
        .chat-history-container {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: #fdfdfd;
            margin-bottom: 20px;
        }
        .message { /* Styling as before */ }
        .message.user { /* Styling as before */ }
        .message.bot { /* Styling as before */ }
        .message-sender { /* Styling as before */ }
        .message-timestamp { /* Styling as before */ }
        .message-content { /* Styling as before */ }
        .message-content .error-text { /* Styling as before */ }
        .message-content em { /* Styling as before */ }
        .message-content pre[class*="language-"] { /* Styling as before */ }

        .chat-input-area { /* Styling as before */ }
        .chat-input-area textarea { /* Styling as before */ }
        .chat-input-area textarea:focus { /* Styling as before */ }
        .chat-input-area button { /* Styling as before */ }
        .chat-input-area button:hover { /* Styling as before */ }
        .chat-input-area button:disabled { /* Styling as before */ }


        .sidebar { /* Styling as before */ }
        .sidebar-section { /* Styling as before */ }
        .sidebar-section h3 { /* Styling as before */ }
        .sidebar-section p { /* Styling as before */ }
        .sidebar-section .btn { /* Styling as before */ }
        .btn-sync { /* Styling as before */ }
        .btn-secondary { /* Styling as before */ }
        .btn-test-api-small { /* Styling as before */ }
        #document-operation-status .status-message { /* Styling as before */ }
        #doc-preview-container .document-preview-area { /* Styling as before */ }
        .stats-panel-content { /* Styling as before */ }
        .stats-grid { /* Styling as before */ }
        .stat-item { /* Styling as before */ }
        .stat-value { /* Styling as before */ }
        .stat-label { /* Styling as before */ }
        .loading-indicator { /* Styling as before */ }
        .spinner { /* Styling as before */ }
        .chat-history-container::-webkit-scrollbar, .sidebar::-webkit-scrollbar { /* Styling as before */ }
        .chat-history-container::-webkit-scrollbar-track, .sidebar::-webkit-scrollbar-track { /* Styling as before */ }
        .chat-history-container::-webkit-scrollbar-thumb, .sidebar::-webkit-scrollbar-thumb { /* Styling as before */ }
        .chat-history-container::-webkit-scrollbar-thumb:hover, .sidebar::-webkit-scrollbar-thumb:hover { /* Styling as before */ }

        @media (max-width: 992px) {
            .app-main-layout { flex-direction: column; }
            .main-content-area { border-right: none; border-bottom: 1px solid var(--border-color); padding: 0px 10px 10px 10px; }
            .sidebar { max-height: none; padding: 10px; }
            .tabs-nav { margin-left:10px; margin-right:10px; } /* Adjust tab nav margin */
        }
         @media (max-width: 768px) {
            body { padding: 0; }
            .app-container { height: 100vh; border-radius: 0; box-shadow: none; }
            .app-header { padding: 12px 15px; }
            .app-header-title h1 { font-size: 1.25em; }
            .app-header-info { font-size: 0.8em;}
            .app-main-layout { padding: 0px; gap:0px; } /* Remove padding and gap */
            .main-content-area, .sidebar { padding: 10px; }
            .sidebar-section {padding: 15px;}
            /* Adjust chat history height more dynamically for small screens */
            .chat-history-container { height: calc(100vh - 320px); /* Example adjustment */ }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <div class="app-header-title">
                <h1>Enterprise AI Assistant</h1>
            </div>
            <div class="app-header-info">
                <div>👤 User: {{ user_login }}</div>
                <div><span id="tehran-time-display">--:--:--</span> (Tehran Time)</div>
                <div>🤖 API: <span id="api-status-text">Initializing...</span></div>
            </div>
        </header>

        <main class="app-main-layout">
            <div class="main-content-area">
                <nav class="tabs-nav">
                    <button class="tab-button active" onclick="openTab(event, 'sqlBotTab')">SQL Query Bot</button>
                    <button class="tab-button" onclick="openTab(event, 'generalChatTab')">General Chat</button>
                </nav>

                <div id="sqlBotTab" class="tab-content active">
                    <div class="chat-interaction-wrapper">
                        <div class="chat-history-container" id="sql-chat-messages-container">
                             <div class="message bot">
                                <div class="message-sender">SQL Assistant <span class="message-timestamp" id="sql-initial-welcome-time"></span></div>
                                <div class="message-content">SQL Bot ready. I use the local 'extracted_edit_url.txt' for context. Update it via the sidebar if needed.</div>
                            </div>
                        </div>
                        <div class="loading-indicator" id="sql-chat-loading-spinner">
                            <div class="spinner"></div> <p>Processing SQL Query...</p>
                        </div>
                        <div class="chat-input-area">
                            <textarea id="sql-question-input-field" placeholder="Type your SQL query request here... (Ctrl+Enter to send)" disabled rows="2"></textarea>
                            <button id="sql-ask-question-button" onclick="handleAskSQLQuestion()" disabled title="Send (Ctrl+Enter)">➔</button>
                        </div>
                    </div>
                </div>

                <div id="generalChatTab" class="tab-content">
                    <div class="chat-interaction-wrapper">
                        <div class="chat-history-container" id="general-chat-messages-container">
                            <div class="message bot">
                                <div class="message-sender">General Assistant <span class="message-timestamp" id="general-initial-welcome-time"></span></div>
                                <div class="message-content">Hello! I'm ready for a general conversation. Ask me anything!</div>
                            </div>
                        </div>
                         <div class="loading-indicator" id="general-chat-loading-spinner">
                            <div class="spinner"></div> <p>Thinking...</p>
                        </div>
                        <div class="chat-input-area">
                            <textarea id="general-chat-input-field" placeholder="Type your message here... (Ctrl+Enter to send)"></textarea>
                            <button id="general-chat-send-button" onclick="handleSendGeneralChatMessage()" title="Send (Ctrl+Enter)">➔</button>
                        </div>
                    </div>
                </div>
            </div>

            <aside class="sidebar">
                <div class="sidebar-section">
                    <h3>📄 Document Control <small>(for SQL Bot)</small></h3>
                    <p>Source: <strong id="doc-source-display">Loading...</strong></p>
                    <button class="btn btn-sync" onclick="handleSyncFromOneDrive()" id="sync-onedrive-button">🔄 Sync & Reload File</button>
                    <p style="font-size:0.8em; margin-top:2px; color: var(--text-secondary);">Updates 'extracted_edit_url.txt'.</p>
                    <button class="btn btn-secondary" onclick="handleCheckStatus()" style="margin-top:10px;">ℹ️ Check Status</button>
                    <div id="document-operation-status"></div>
                    <div id="doc-preview-container"></div>
                </div>

                <div class="sidebar-section">
                    <h3>📊 Session Statistics <small>(Combined)</small></h3>
                    <div class="stats-panel-content">
                        <div class="stats-grid">
                            <div class="stat-item"><div class="stat-value" id="stat-queries">0</div><div class="stat-label">Total Queries</div></div>
                            <div class="stat-item"><div class="stat-value" id="stat-total-tokens">0</div><div class="stat-label">Total Tokens</div></div>
                            <div class="stat-item"><div class="stat-value" id="stat-doc-chars">0</div><div class="stat-label">Doc Chars (SQL)</div></div>
                            <div class="stat-item"><div class="stat-value" id="stat-total-cost">$0.00</div><div class="stat-label">Total Cost</div></div>
                            <div class="stat-item"><div class="stat-value" id="stat-avg-cost">$0.00</div><div class="stat-label">Avg. Cost/Query</div></div>
                            <div class="stat-item"><div class="stat-value" id="stat-avg-time">0s</div><div class="stat-label">Avg. Time/Query</div></div>
                        </div>
                    </div>
                     <button class="btn btn-test-api-small" onclick="handleTestAPI()" style="margin-top: 15px; display: block; text-align:center;">Test API Connectivity</button>
                </div>
            </aside>
        </main>
    </div>

    <script>
        let isDocumentLoaded = false; // For SQL Bot
        const sessionActivityStats = { queries: 0, totalTokens: 0, totalCost: 0.0, documentChars: 0, totalResponseTimeMs: 0.0 };
        let generalChatHistory = []; // To keep track of general chat messages for context

        // --- DOM Elements ---
        const tehranTimeDisplay = document.getElementById('tehran-time-display');
        const apiStatusText = document.getElementById('api-status-text');

        // SQL Bot Elements
        const sqlInitialWelcomeTime = document.getElementById('sql-initial-welcome-time');
        const sqlChatMessagesContainer = document.getElementById('sql-chat-messages-container');
        const sqlChatLoadingSpinner = document.getElementById('sql-chat-loading-spinner');
        const sqlQuestionInputField = document.getElementById('sql-question-input-field');
        const sqlAskQuestionButton = document.getElementById('sql-ask-question-button');

        // General Chat Elements
        const generalInitialWelcomeTime = document.getElementById('general-initial-welcome-time');
        const generalChatMessagesContainer = document.getElementById('general-chat-messages-container');
        const generalChatLoadingSpinner = document.getElementById('general-chat-loading-spinner');
        const generalChatInputField = document.getElementById('general-chat-input-field');
        const generalChatSendButton = document.getElementById('general-chat-send-button');

        // Sidebar & Common Elements
        const documentOperationStatus = document.getElementById('document-operation-status');
        const docPreviewContainer = document.getElementById('doc-preview-container');
        const docSourceDisplay = document.getElementById('doc-source-display');
        const statQueries = document.getElementById('stat-queries');
        const statTotalTokens = document.getElementById('stat-total-tokens');
        const statDocChars = document.getElementById('stat-doc-chars');
        const statTotalCost = document.getElementById('stat-total-cost');
        const statAvgCost = document.getElementById('stat-avg-cost');
        const statAvgTime = document.getElementById('stat-avg-time');

        // --- Tab Management ---
        function openTab(evt, tabName) {
            let i, tabcontent, tabbuttons;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
                tabcontent[i].classList.remove("active");
            }
            tabbuttons = document.getElementsByClassName("tab-button");
            for (i = 0; i < tabbuttons.length; i++) {
                tabbuttons[i].classList.remove("active");
            }
            document.getElementById(tabName).style.display = "flex"; // Use flex for active tab
            document.getElementById(tabName).classList.add("active");
            evt.currentTarget.classList.add("active");
        }

        // --- Time Update ---
        function updateTehranTime() { /* ... (identical to previous) ... */ if (tehranTimeDisplay) { try { const tehranTime = new Date().toLocaleTimeString("en-GB", { timeZone: "Asia/Tehran", hour: '2-digit', minute: '2-digit', second: '2-digit', hourCycle: 'h23' }); tehranTimeDisplay.textContent = tehranTime; } catch (e) { console.warn("Timezone Asia/Tehran not available", e); tehranTimeDisplay.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });}}}

        // --- Utility Functions ---
        function escapeHtml(unsafeText) { /* ... (identical) ... */ if (typeof unsafeText !== 'string') return unsafeText; return unsafeText.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); }
        function showOpStatus(message, type = 'info') { /* ... (identical) ... */ documentOperationStatus.innerHTML = `<div class="status-message ${type}">${escapeHtml(message)}</div>`; if (type !== 'error' && type !== 'info') { setTimeout(() => { if (documentOperationStatus.innerHTML.includes(escapeHtml(message))) documentOperationStatus.innerHTML = ''; }, 7000);}}

        function showLoadingSpinner(spinnerElement, isLoading) {
            if(spinnerElement) spinnerElement.style.display = isLoading ? 'flex' : 'none';
        }

        function updateSessionStatsDisplay() { /* ... (identical) ... */ statQueries.textContent = sessionActivityStats.queries; statTotalTokens.textContent = sessionActivityStats.totalTokens.toLocaleString(); statTotalCost.textContent = `$${sessionActivityStats.totalCost.toFixed(6)}`; statDocChars.textContent = sessionActivityStats.documentChars.toLocaleString(); const avgCost = sessionActivityStats.queries > 0 ? (sessionActivityStats.totalCost / sessionActivityStats.queries) : 0; statAvgCost.textContent = `$${avgCost.toFixed(6)}`; const avgTimeInSeconds = sessionActivityStats.queries > 0 ? (sessionActivityStats.totalResponseTimeMs / sessionActivityStats.queries / 1000) : 0;  statAvgTime.textContent = `${avgTimeInSeconds.toFixed(1)}s`;  }

        // --- Chat Message Handling (Generalized) ---
        function addMessageToContainer(container, text, senderIsUser = false, apiMeta = {}, isStreaming = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${senderIsUser ? 'user' : 'bot'}`;
            if (isStreaming && !senderIsUser) { // Give streaming bot messages a unique ID to append to
                messageDiv.id = `stream-msg-${Date.now()}`;
            }
            const messageTimestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            let messageContentHtml = '';
            const isApiError = !senderIsUser && apiMeta && typeof apiMeta.error === 'string';
            const sqlKeywordsRegex = /\b(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP|FROM|WHERE|JOIN|GRANT|REVOKE|WITH|VALUES|TABLE|VIEW|INDEX|DATABASE|PROCEDURE|FUNCTION)\b/i;
            const responseText = (typeof text === 'string') ? text : "";

            if (isApiError) {
                messageContentHtml = `<div class="error-text"><strong>Error:</strong> ${escapeHtml(responseText)}</div>`;
            } else if (!senderIsUser && apiMeta && apiMeta.success === true) {
                if (container === sqlChatMessagesContainer && sqlKeywordsRegex.test(responseText)) { // Only apply SQL for SQL bot
                    messageContentHtml = `<pre><code class="language-sql">${escapeHtml(responseText)}</code></pre>`;
                } else if (responseText.trim() === "" || responseText.trim() === "[API Call Successful but no message content in choices]") {
                    messageContentHtml = `<em>[API returned an empty or non-substantive answer.]</em>`;
                } else {
                    messageContentHtml = escapeHtml(responseText).replace(/\n/g, '<br>');
                }
            } else if (senderIsUser) {
                 messageContentHtml = escapeHtml(responseText).replace(/\n/g, '<br>');
            } else { // General bot informational messages (e.g., welcome, status updates)
                 messageContentHtml = escapeHtml(responseText).replace(/\n/g, '<br>');
            }

            // Update global stats if it's a bot message with usage info (typically non-streaming or final stream event)
            if (!senderIsUser && (apiMeta.success === true || isApiError)) {
                if (!isStreaming || (apiMeta.type === 'done' || apiMeta.type === 'usage')) { // Only update stats for non-streaming or final stream event with duration/usage
                    sessionActivityStats.queries++;
                    if (apiMeta.duration_ms) {
                        sessionActivityStats.totalResponseTimeMs += parseFloat(apiMeta.duration_ms) || 0;
                    }
                    // Cost calculation relies on backend sending query_cost OR if we parse tokens client-side from stream for free models
                    if (apiMeta.usage && apiMeta.usage.query_cost) {
                        sessionActivityStats.totalTokens += apiMeta.usage.total_tokens || 0;
                        sessionActivityStats.totalCost += parseFloat(apiMeta.usage.query_cost) || 0.0;
                    } else if (apiMeta.usage) { // Fallback for just tokens
                         sessionActivityStats.totalTokens += apiMeta.usage.total_tokens || 0;
                    }
                    updateSessionStatsDisplay();
                }
            }

            messageDiv.innerHTML = `
                <div class="message-sender">${senderIsUser ? 'You' : (container === sqlChatMessagesContainer ? 'SQL Assistant' : 'General Assistant')} <span class="message-timestamp">${messageTimestamp}</span></div>
                <div class="message-content">${messageContentHtml}</div>`;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;

            if (!isApiError && !senderIsUser && apiMeta && apiMeta.success === true && container === sqlChatMessagesContainer && sqlKeywordsRegex.test(responseText)) {
                const codeBlock = messageDiv.querySelector('code.language-sql');
                if (codeBlock && window.Prism) Prism.highlightElement(codeBlock);
            }
            return messageDiv.id; // Return ID for streaming updates
        }

        async function makeApiRequest(endpoint, method = 'GET', body = null) {
            const isAskQuestion = endpoint === '/ask_question';
            const isLoadingForSpinner = isAskQuestion || endpoint === '/sync_onedrive_document';

            if(isLoadingForSpinner) showLoadingSpinner(sqlChatLoadingSpinner, true); // SQL bot spinner for these

            const fullUrl = window.location.origin + endpoint;
            console.log("Attempting to fetch: " + fullUrl);

            try {
                const opt = { method };
                if (body) { opt.headers = {'Content-Type': 'application/json'}; opt.body = JSON.stringify(body); }
                const resp = await fetch(fullUrl, opt);
                if (!resp.ok) {
                    const errorText = await resp.text();
                    console.error(`HTTP error ${resp.status} for ${fullUrl}: ${errorText.substring(0,500)}`);
                    throw new Error(`HTTP error ${resp.status}`); // Simplified error for UI
                }
                return await resp.json();
            } catch (e) {
                console.error(`API request to ${fullUrl} failed:`, e);
                return {success:false, error:`Request to ${endpoint} failed: ${e.message}`};
            } finally {
                if(isLoadingForSpinner) showLoadingSpinner(sqlChatLoadingSpinner, false);
            }
        }

        // --- SQL Bot Specific ---
        async function handleAskSQLQuestion() {
            const q = sqlQuestionInputField.value.trim();
            if(!q){showOpStatus('Please enter your SQL query request.','error'); return;}
            if(!isDocumentLoaded){showOpStatus('No document is active for SQL Bot. Please sync or check status.','error');return;}
            addMessageToContainer(sqlChatMessagesContainer, q, true);
            sqlQuestionInputField.value='';
            const res = await makeApiRequest('/ask_question','POST',{question:q});
            addMessageToContainer(sqlChatMessagesContainer, res.success ? res.answer : res.error, false, res);
        }

        // --- General Chat Specific ---
        let currentGeneralChatStreamTargetId = null;
        async function handleSendGeneralChatMessage() {
            const messageText = generalChatInputField.value.trim();
            if (!messageText) return;

            addMessageToContainer(generalChatMessagesContainer, messageText, true);
            generalChatHistory.push({"role": "user", "content": messageText});
            generalChatInputField.value = '';
            showLoadingSpinner(generalChatLoadingSpinner, true);

            currentGeneralChatStreamTargetId = addMessageToContainer(generalChatMessagesContainer, "", false, {success:true}, true); // Add placeholder for bot response
            let botResponseText = "";

            try {
                const eventSource = new EventSource(window.location.origin + '/stream_general_chat', {
                    method: 'POST', // EventSource doesn't natively support POST body, so we use a workaround
                                    // OR ensure backend handles GET if EventSource is strict (less common for POST data)
                                    // For simplicity with fetch-like API, assuming a library or polyfill might allow POST,
                                    // otherwise, this needs a different streaming approach or backend adjustment.
                                    // A more robust way is to use fetch with ReadableStream for POST.
                                    // Given the current simple backend, let's assume direct EventSource with GET for now,
                                    // and messages would need to be passed differently (e.g. as query params, not ideal for chat history).
                                    // **Correction**: EventSource standard does not support POST.
                                    // We need to use fetch API with ReadableStream for streaming POST.
                });
                // ---- Using Fetch API for Streaming POST ----
                const response = await fetch(window.location.origin + '/stream_general_chat', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({messages: generalChatHistory})
                });

                if (!response.ok) {
                    const errorData = await response.json(); // Or response.text()
                    throw new Error(errorData.error || `HTTP error ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let done = false;
                let serverSentEventBuffer = "";

                while (!done) {
                    const { value, done: readerDone } = await reader.read();
                    done = readerDone;
                    if (value) {
                        serverSentEventBuffer += decoder.decode(value, { stream: true });
                        let eventEndIndex;
                        while ((eventEndIndex = serverSentEventBuffer.indexOf("\n\n")) >= 0) {
                            const eventString = serverSentEventBuffer.substring(0, eventEndIndex);
                            serverSentEventBuffer = serverSentEventBuffer.substring(eventEndIndex + 2);

                            if (eventString.startsWith("data: ")) {
                                const jsonDataString = eventString.substring(6);
                                try {
                                    const eventData = JSON.parse(jsonDataString);
                                    const targetMessageDiv = document.getElementById(currentGeneralChatStreamTargetId);
                                    if (targetMessageDiv) {
                                        const contentDiv = targetMessageDiv.querySelector('.message-content');
                                        if (eventData.type === "content") {
                                            botResponseText += eventData.delta;
                                            contentDiv.innerHTML = escapeHtml(botResponseText).replace(/\n/g, '<br>');
                                        } else if (eventData.type === "done") {
                                            console.log("Stream finished by server 'done' event.", eventData);
                                            generalChatHistory.push({"role": "assistant", "content": botResponseText});
                                            sessionActivityStats.queries++; // Count after 'done'
                                            if(eventData.duration_ms) sessionActivityStats.totalResponseTimeMs += parseFloat(eventData.duration_ms);
                                            // Add logic here if 'done' event includes usage for cost calculation
                                            updateSessionStatsDisplay();
                                            showLoadingSpinner(generalChatLoadingSpinner, false);
                                            return; // End of stream
                                        } else if (eventData.type === "error") {
                                            contentDiv.innerHTML = `<div class="error-text"><strong>Stream Error:</strong> ${escapeHtml(eventData.delta)}</div>`;
                                            showLoadingSpinner(generalChatLoadingSpinner, false);
                                            return;
                                        }
                                    }
                                } catch (e) {
                                    console.error("Error parsing SSE JSON:", e, jsonDataString);
                                }
                            }
                        }
                    }
                }
                // If loop finishes, it means stream ended without explicit "done" or "error" from our processing.
                if(botResponseText) generalChatHistory.push({"role": "assistant", "content": botResponseText});
                showLoadingSpinner(generalChatLoadingSpinner, false);

            } catch (error) {
                console.error('Streaming chat error:', error);
                const targetMessageDiv = document.getElementById(currentGeneralChatStreamTargetId);
                if (targetMessageDiv) {
                    targetMessageDiv.querySelector('.message-content').innerHTML = `<div class="error-text"><strong>Error:</strong> ${escapeHtml(error.message)}</div>`;
                } else { // Fallback if placeholder message div wasn't found/created
                    addMessageToContainer(generalChatMessagesContainer, error.message, false, { error: error.message, success: false });
                }
                showLoadingSpinner(generalChatLoadingSpinner, false);
            }
        }


        // --- Document Management and Status (Mostly for SQL Bot) ---
        async function handleTestAPI() { /* ... (identical to previous, uses addMessageToContainer(sqlChatMessagesContainer,...) ) ... */ apiStatusText.textContent='📡 Testing...'; const res = await makeApiRequest('/test_api'); if(res.success){ apiStatusText.textContent='✅ Online'; addMessageToContainer(sqlChatMessagesContainer, `API Test OK: ${res.answer}`,false, {success: true, model_used: res.model_used, duration_ms: res.duration_ms, usage: res.usage}); } else { apiStatusText.textContent='❌ Error'; addMessageToContainer(sqlChatMessagesContainer, res.error||'API Test Failed.',false,{ error: (res.error || 'Unknown test API error'), success: false, duration_ms: res.duration_ms });}}
        async function handleSyncFromOneDrive() { /* ... (identical, uses addMessageToContainer(sqlChatMessagesContainer,...) ) ... */ showOpStatus('Syncing...','info'); docPreviewContainer.innerHTML = ''; const res = await makeApiRequest('/sync_onedrive_document','POST'); if(res.success){addMessageToContainer(sqlChatMessagesContainer,res.message||'Doc synced.',false,{success:true});}else{addMessageToContainer(sqlChatMessagesContainer,res.error||'Sync failed.',false,{error:res.error,success:false});} updateDocumentStatusUI(res);}
        function updateDocumentStatusUI(statusResult) { /* ... (identical) ... */ const chars = statusResult.characters||0; const src = statusResult.source||"None"; isDocumentLoaded = statusResult.loaded && chars > 0; sessionActivityStats.documentChars = chars; if(docSourceDisplay)docSourceDisplay.textContent=src; if(isDocumentLoaded){if(docPreviewContainer&&statusResult.preview){docPreviewContainer.innerHTML=`<div class="document-preview-area"><strong>📄 Preview (${chars.toLocaleString()} chars):</strong><br>${escapeHtml(statusResult.preview)}</div>`;}else if(docPreviewContainer){docPreviewContainer.innerHTML='';} sqlQuestionInputField.disabled=false; sqlAskQuestionButton.disabled=false;}else{if(docPreviewContainer)docPreviewContainer.innerHTML=''; sqlQuestionInputField.disabled=true; sqlAskQuestionButton.disabled=true;} updateSessionStatsDisplay();}
        async function handleCheckStatus() { /* ... (identical) ... */ showOpStatus('Checking status...','info'); const res = await makeApiRequest('/status'); updateDocumentStatusUI(res); if(res.loaded){showOpStatus(`Status: '${res.source}' active (${(res.characters||0).toLocaleString()} chars).`,'info');}else{showOpStatus('Status: No doc active.','info');}}
        async function handleClearDocument() { /* ... (identical, uses addMessageToContainer(sqlChatMessagesContainer,...) ) ... */  addMessageToContainer(sqlChatMessagesContainer, "The 'Reset' button was removed. Use 'Sync & Reload File'. To reset client stats, refresh page.",false,{success:true}); }

        // --- Event Listeners & Initialization ---
        sqlQuestionInputField.addEventListener('keypress', function(e) { if(e.key==='Enter'&&e.ctrlKey){e.preventDefault();handleAskSQLQuestion();}});
        generalChatInputField.addEventListener('keypress', function(e) { if(e.key==='Enter'&&e.ctrlKey){e.preventDefault();handleSendGeneralChatMessage();}});

        window.onload = () => {
            updateTehranTime();
            setInterval(updateTehranTime,1000);
            if(sqlInitialWelcomeTime)sqlInitialWelcomeTime.textContent=new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
            if(generalInitialWelcomeTime)generalInitialWelcomeTime.textContent=new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'});
            updateSessionStatsDisplay();
            handleCheckStatus();
            setTimeout(handleTestAPI,700);
            // Set default tab
            document.querySelector('.tab-button.active').click();
        };
    </script>
</body>
</html>

